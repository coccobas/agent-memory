{"text":"<|user|>Is this approach correct for TypeScript Strict Mode & Type Imports?\n\nfunction process(value: any) { ... }<|assistant|>No, this violates the guideline. The correct approach is: Always use TypeScript strict mode. Use type-only imports for types: `import type { ... } from '...'`. Prefer interfaces for contracts and types for data shapes. Use discriminated unions for query parameters. Never use `any` - use `unknown` with type guards instead.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>How should I handle mcp: flatten tool arguments?<|assistant|>Use top-level primitive arguments, not nested objects or config dictionaries. Use Literal types or enums for constrained choices. Avoid tightly coupled arguments where valid values for one depend on another. LLMs struggle with complex argument structures and some clients serialize objects incorrectly.<|end|>","metadata":{"type":"validation_query","category":"mcp-design","priority":90}}
{"text":"<|user|>Is this approach correct for MCP: Understand Agent Limitations?\n\nBundled operations that minimize round-trips<|assistant|>Yes, this follows the guideline. Agents differ from humans on three dimensions: 1) Discovery is expensive (happens every handshake, not once), 2) Iteration is slow (each call sends full history, costs tokens), 3) Context is limited (200k tokens max, no long-term memory). Design for these constraints, not human developer workflows.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>How should I handle typescript strict mode & type imports?<|assistant|>Always use TypeScript strict mode. Use type-only imports for types: `import type { ... } from '...'`. Prefer interfaces for contracts and types for data shapes. Use discriminated unions for query parameters. Never use `any` - use `unknown` with type guards instead.<|end|>","metadata":{"type":"validation_query","category":"typescript","priority":90}}
{"text":"<|user|>I need guidance on mcp: understand agent limitations. What should I know?<|assistant|>Here's the guideline: Agents differ from humans on three dimensions: 1) Discovery is expensive (happens every handshake, not once), 2) Iteration is slow (each call sends full history, costs tokens), 3) Context is limited (200k tokens max, no long-term memory). Design for these constraints, not human developer workflows.<|end|>","metadata":{"type":"contextual_query","category":"mcp-design","priority":90}}
{"text":"<|user|>Is this approach correct for Error Handling Pattern?\n\nthrow { message: 'not found' };<|assistant|>No, this violates the guideline. The correct approach is: Use custom `AgentMemoryError` with namespaced error codes (E1000-E1999 for validation, E2000-E2999 for resources). Create errors with factory functions: `createValidationError()`, `createNotFoundError()`, `createPermissionError()`. Sanitize error messages in production to prevent info disclosure.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>What is the guideline for \"Service Factory Pattern\"?<|assistant|>Create services with explicit dependencies injected via constructor. Use factory functions: `createValidationService()`, `createComponentLogger()`. Services should not hold module-level state - use instance-level caches for test isolation.<|end|>","metadata":{"type":"direct_query","category":"services","priority":85}}
{"text":"<|user|>Is this approach correct for MCP: Understand Agent Limitations?\n\nConcise descriptions that fit token budget<|assistant|>Yes, this follows the guideline. Agents differ from humans on three dimensions: 1) Discovery is expensive (happens every handshake, not once), 2) Iteration is slow (each call sends full history, costs tokens), 3) Context is limited (200k tokens max, no long-term memory). Design for these constraints, not human developer workflows.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>What is the guideline for \"MCP: Understand Agent Limitations\"?<|assistant|>Agents differ from humans on three dimensions: 1) Discovery is expensive (happens every handshake, not once), 2) Iteration is slow (each call sends full history, costs tokens), 3) Context is limited (200k tokens max, no long-term memory). Design for these constraints, not human developer workflows.<|end|>","metadata":{"type":"direct_query","category":"mcp-design","priority":90}}
{"text":"<|user|>How should I handle class and function naming?<|assistant|>Use PascalCase for classes: `PermissionService`, `SQLiteStorageAdapter`. Use camelCase for functions: `extractAddParams()`, `validateEmbedding()`. Type guard functions use `is` prefix: `isString()`, `isScopeType()`, `isEntryType()`.<|end|>","metadata":{"type":"validation_query","category":"naming","priority":85}}
{"text":"<|user|>How should I handle service factory pattern?<|assistant|>Create services with explicit dependencies injected via constructor. Use factory functions: `createValidationService()`, `createComponentLogger()`. Services should not hold module-level state - use instance-level caches for test isolation.<|end|>","metadata":{"type":"validation_query","category":"services","priority":85}}
{"text":"<|user|>What is the guideline for \"always-use-typescript-strict\"?<|assistant|>Always use TypeScript strict mode for all new files. Enable noImplicitAny and strictNullChecks.<|end|>","metadata":{"type":"direct_query","category":"code_style","priority":100}}
{"text":"<|user|>How should I handle mcp: outcomes over operations?<|assistant|>Design MCP tools for complete workflows, not atomic API operations. One tool should equal one 'agent story' - a complete task the agent wants to accomplish. Don't make the agent orchestrate multiple tool calls when you can bundle the logic server-side. Agents are slow and expensive orchestrators; if you know the workflow, implement it in code.<|end|>","metadata":{"type":"validation_query","category":"mcp-design","priority":95}}
{"text":"<|user|>Is this approach correct for Graceful Degradation Pattern?\n\nconst result = await autoTagService.tag(entry); // Will break if service unavailable<|assistant|>No, this violates the guideline. The correct approach is: Non-critical features should fail gracefully without breaking core functionality. Use `safeAsync()` wrapper with default fallback values. Examples: auto-tagging, red flag detection, duplicate checking. Critical operations (permissions, validation) should fail-fast.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>I need guidance on mcp: respect the token budget. What should I know?<|assistant|>Here's the guideline: Keep total tools per agent under 50. Each tool's schema + description consumes context on every handshake. With 200k token context and 800 tools, each tool gets ~250 tokens total - including schema. Prefer 5-15 tools when possible. Token budget is the only hard constraint - violating it makes your server unusable.<|end|>","metadata":{"type":"contextual_query","category":"mcp-design","priority":95}}
{"text":"<|user|>I need guidance on mcp: instructions are context. What should I know?<|assistant|>Here's the guideline: Document your MCP server and all tools thoroughly - undocumented tools force agents to guess. Use the server's instructions field for high-level guidance. Examples are contracts: agents will follow example patterns literally (e.g., example with 2 tags = always 2 tags). Errors are prompts: helpful error messages guide recovery and become part of the next prompt.<|end|>","metadata":{"type":"contextual_query","category":"mcp-design","priority":85}}
{"text":"<|user|>What is the guideline for \"MCP: Outcomes Over Operations\"?<|assistant|>Design MCP tools for complete workflows, not atomic API operations. One tool should equal one 'agent story' - a complete task the agent wants to accomplish. Don't make the agent orchestrate multiple tool calls when you can bundle the logic server-side. Agents are slow and expensive orchestrators; if you know the workflow, implement it in code.<|end|>","metadata":{"type":"direct_query","category":"mcp-design","priority":95}}
{"text":"<|user|>I need guidance on type guard validation. What should I know?<|assistant|>Here's the guideline: Use runtime type guards for all parameter validation. Use `getRequiredParam(params, key, typeGuard)` and `getOptionalParam(params, key, typeGuard)` for safe extraction. Never cast types without validation.<|end|>","metadata":{"type":"contextual_query","category":"validation","priority":90}}
{"text":"<|user|>What is the guideline for \"MCP: Flatten Tool Arguments\"?<|assistant|>Use top-level primitive arguments, not nested objects or config dictionaries. Use Literal types or enums for constrained choices. Avoid tightly coupled arguments where valid values for one depend on another. LLMs struggle with complex argument structures and some clients serialize objects incorrectly.<|end|>","metadata":{"type":"direct_query","category":"mcp-design","priority":90}}
{"text":"<|user|>Is this approach correct for TypeScript Strict Mode & Type Imports?\n\nimport { CreateKnowledgeInput } from '...';<|assistant|>No, this violates the guideline. The correct approach is: Always use TypeScript strict mode. Use type-only imports for types: `import type { ... } from '...'`. Prefer interfaces for contracts and types for data shapes. Use discriminated unions for query parameters. Never use `any` - use `unknown` with type guards instead.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>Is this approach correct for TypeScript Strict Mode & Type Imports?\n\nfunction process(value: unknown): value is string { return typeof value === 'string'; }<|assistant|>Yes, this follows the guideline. Always use TypeScript strict mode. Use type-only imports for types: `import type { ... } from '...'`. Prefer interfaces for contracts and types for data shapes. Use discriminated unions for query parameters. Never use `any` - use `unknown` with type guards instead.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>Is this approach correct for MCP: Curate Ruthlessly?\n\nAuto-converting 800 REST endpoints to MCP tools<|assistant|>No, this violates the guideline. The correct approach is: Start with what works, then tear it down to essentials. Don't just wrap REST APIs as MCP tools - that violates every design principle. Name tools for the agent (clear intent), not for developers (technical accuracy). Remove tools that aren't essential; each additional tool degrades performance.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>Is this approach correct for Error Handling Pattern?\n\nthrow createValidationError('params', 'parameter validation failed');<|assistant|>Yes, this follows the guideline. Use custom `AgentMemoryError` with namespaced error codes (E1000-E1999 for validation, E2000-E2999 for resources). Create errors with factory functions: `createValidationError()`, `createNotFoundError()`, `createPermissionError()`. Sanitize error messages in production to prevent info disclosure.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>Is this approach correct for MCP: Outcomes Over Operations?\n\nExposing raw REST endpoints as separate tools<|assistant|>No, this violates the guideline. The correct approach is: Design MCP tools for complete workflows, not atomic API operations. One tool should equal one 'agent story' - a complete task the agent wants to accomplish. Don't make the agent orchestrate multiple tool calls when you can bundle the logic server-side. Agents are slow and expensive orchestrators; if you know the workflow, implement it in code.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>How should I handle file naming convention?<|assistant|>Use kebab-case for all file names with domain-specific suffixes: `{domain}.{layer}.ts`. Examples: `knowledge.handler.ts`, `embedding.service.ts`, `sqlite.adapter.ts`, `permission.service.ts`. Test files use `.test.ts` suffix.<|end|>","metadata":{"type":"validation_query","category":"naming","priority":85}}
{"text":"<|user|>Is this approach correct for MCP: Understand Agent Limitations?\n\nExposing raw API endpoints<|assistant|>No, this violates the guideline. The correct approach is: Agents differ from humans on three dimensions: 1) Discovery is expensive (happens every handshake, not once), 2) Iteration is slow (each call sends full history, costs tokens), 3) Context is limited (200k tokens max, no long-term memory). Design for these constraints, not human developer workflows.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>Is this approach correct for Graceful Degradation Pattern?\n\nconst result = await safeAsync(() => autoTagService.tag(entry), { name: 'autoTag' }, { tags: [] });<|assistant|>Yes, this follows the guideline. Non-critical features should fail gracefully without breaking core functionality. Use `safeAsync()` wrapper with default fallback values. Examples: auto-tagging, red flag detection, duplicate checking. Critical operations (permissions, validation) should fail-fast.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>Is this approach correct for MCP: Instructions Are Context?\n\nError: 'ValueError: empty'<|assistant|>No, this violates the guideline. The correct approach is: Document your MCP server and all tools thoroughly - undocumented tools force agents to guess. Use the server's instructions field for high-level guidance. Examples are contracts: agents will follow example patterns literally (e.g., example with 2 tags = always 2 tags). Errors are prompts: helpful error messages guide recovery and become part of the next prompt.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>I need guidance on service factory pattern. What should I know?<|assistant|>Here's the guideline: Create services with explicit dependencies injected via constructor. Use factory functions: `createValidationService()`, `createComponentLogger()`. Services should not hold module-level state - use instance-level caches for test isolation.<|end|>","metadata":{"type":"contextual_query","category":"services","priority":85}}
{"text":"<|user|>How should I handle typescript-strict-mode?<|assistant|>Enable TypeScript strict mode in all projects<|end|>","metadata":{"type":"validation_query","category":"code_style","priority":90}}
{"text":"<|user|>Is this approach correct for Error Handling Pattern?\n\nthrow createNotFoundError('knowledge', id);<|assistant|>Yes, this follows the guideline. Use custom `AgentMemoryError` with namespaced error codes (E1000-E1999 for validation, E2000-E2999 for resources). Create errors with factory functions: `createValidationError()`, `createNotFoundError()`, `createPermissionError()`. Sanitize error messages in production to prevent info disclosure.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>Is this approach correct for TypeScript Strict Mode & Type Imports?\n\nimport type { CreateKnowledgeInput } from '...';<|assistant|>Yes, this follows the guideline. Always use TypeScript strict mode. Use type-only imports for types: `import type { ... } from '...'`. Prefer interfaces for contracts and types for data shapes. Use discriminated unions for query parameters. Never use `any` - use `unknown` with type guards instead.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>How should I handle permission check pattern?<|assistant|>Check permissions before any data access (Bug #338). Use `requirePermission()` for single entries, `requirePermissionBatch()` for bulk operations. Always pass explicit `entryId` (or null for type-level checks) per Bug #340.<|end|>","metadata":{"type":"validation_query","category":"security","priority":95}}
{"text":"<|user|>What is the guideline for \"prioritize-bug-patterns\"?<|assistant|>Check bug patterns before TODO, limitation, decision, fact, and guideline patterns.<|end|>","metadata":{"type":"direct_query","category":"workflow","priority":90}}
{"text":"<|user|>What is the guideline for \"TypeScript Strict Mode & Type Imports\"?<|assistant|>Always use TypeScript strict mode. Use type-only imports for types: `import type { ... } from '...'`. Prefer interfaces for contracts and types for data shapes. Use discriminated unions for query parameters. Never use `any` - use `unknown` with type guards instead.<|end|>","metadata":{"type":"direct_query","category":"typescript","priority":90}}
{"text":"<|user|>How should I handle transaction safety pattern?<|assistant|>Wrap multi-entry operations in `transactionWithDb()`. For SQLite: promises must resolve synchronously within transaction. For PostgreSQL: automatic retry on transient errors. Re-check for existing entries inside transaction for TOCTOU safety (Bug #30).<|end|>","metadata":{"type":"validation_query","category":"database","priority":90}}
{"text":"<|user|>Is this approach correct for MCP: Respect the Token Budget?\n\nVerbose multi-paragraph tool descriptions<|assistant|>No, this violates the guideline. The correct approach is: Keep total tools per agent under 50. Each tool's schema + description consumes context on every handshake. With 200k token context and 800 tools, each tool gets ~250 tokens total - including schema. Prefer 5-15 tools when possible. Token budget is the only hard constraint - violating it makes your server unusable.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>I need guidance on file naming convention. What should I know?<|assistant|>Here's the guideline: Use kebab-case for all file names with domain-specific suffixes: `{domain}.{layer}.ts`. Examples: `knowledge.handler.ts`, `embedding.service.ts`, `sqlite.adapter.ts`, `permission.service.ts`. Test files use `.test.ts` suffix.<|end|>","metadata":{"type":"contextual_query","category":"naming","priority":85}}
{"text":"<|user|>I need guidance on class and function naming. What should I know?<|assistant|>Here's the guideline: Use PascalCase for classes: `PermissionService`, `SQLiteStorageAdapter`. Use camelCase for functions: `extractAddParams()`, `validateEmbedding()`. Type guard functions use `is` prefix: `isString()`, `isScopeType()`, `isEntryType()`.<|end|>","metadata":{"type":"contextual_query","category":"naming","priority":85}}
{"text":"<|user|>Is this approach correct for MCP: Outcomes Over Operations?\n\nmemory_quickstart(sessionName) - combines context load + session start<|assistant|>Yes, this follows the guideline. Design MCP tools for complete workflows, not atomic API operations. One tool should equal one 'agent story' - a complete task the agent wants to accomplish. Don't make the agent orchestrate multiple tool calls when you can bundle the logic server-side. Agents are slow and expensive orchestrators; if you know the workflow, implement it in code.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>How should I handle prioritize-bug-patterns?<|assistant|>Check bug patterns before TODO, limitation, decision, fact, and guideline patterns.<|end|>","metadata":{"type":"validation_query","category":"workflow","priority":90}}
{"text":"<|user|>I need guidance on mcp: flatten tool arguments. What should I know?<|assistant|>Here's the guideline: Use top-level primitive arguments, not nested objects or config dictionaries. Use Literal types or enums for constrained choices. Avoid tightly coupled arguments where valid values for one depend on another. LLMs struggle with complex argument structures and some clients serialize objects incorrectly.<|end|>","metadata":{"type":"contextual_query","category":"mcp-design","priority":90}}
{"text":"<|user|>What is the guideline for \"MCP: Curate Ruthlessly\"?<|assistant|>Start with what works, then tear it down to essentials. Don't just wrap REST APIs as MCP tools - that violates every design principle. Name tools for the agent (clear intent), not for developers (technical accuracy). Remove tools that aren't essential; each additional tool degrades performance.<|end|>","metadata":{"type":"direct_query","category":"mcp-design","priority":90}}
{"text":"<|user|>I need guidance on error handling pattern. What should I know?<|assistant|>Here's the guideline: Use custom `AgentMemoryError` with namespaced error codes (E1000-E1999 for validation, E2000-E2999 for resources). Create errors with factory functions: `createValidationError()`, `createNotFoundError()`, `createPermissionError()`. Sanitize error messages in production to prevent info disclosure.<|end|>","metadata":{"type":"contextual_query","category":"error-handling","priority":90}}
{"text":"<|user|>Is this approach correct for Handler Context Injection?\n\nasync handler(context: AppContext, params: Record<string, unknown>) { ... }<|assistant|>Yes, this follows the guideline. All handlers must accept `AppContext` as the first parameter for dependency injection. Use `contextHandler` in descriptors (not legacy `handler`). Access services via `context.services.*`, repos via `context.repos.*`.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>I need guidance on prioritize-bug-patterns. What should I know?<|assistant|>Here's the guideline: Check bug patterns before TODO, limitation, decision, fact, and guideline patterns.<|end|>","metadata":{"type":"contextual_query","category":"workflow","priority":90}}
{"text":"<|user|>Is this approach correct for MCP: Instructions Are Context?\n\nError: 'scopeId required when scopeType is project. Try: {scopeType: \"project\", scopeId: \"your-id\"}'<|assistant|>Yes, this follows the guideline. Document your MCP server and all tools thoroughly - undocumented tools force agents to guess. Use the server's instructions field for high-level guidance. Examples are contracts: agents will follow example patterns literally (e.g., example with 2 tags = always 2 tags). Errors are prompts: helpful error messages guide recovery and become part of the next prompt.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>Is this approach correct for MCP: Curate Ruthlessly?\n\n5 well-designed tools covering core workflows<|assistant|>Yes, this follows the guideline. Start with what works, then tear it down to essentials. Don't just wrap REST APIs as MCP tools - that violates every design principle. Name tools for the agent (clear intent), not for developers (technical accuracy). Remove tools that aren't essential; each additional tool degrades performance.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>What is the guideline for \"Handler Context Injection\"?<|assistant|>All handlers must accept `AppContext` as the first parameter for dependency injection. Use `contextHandler` in descriptors (not legacy `handler`). Access services via `context.services.*`, repos via `context.repos.*`.<|end|>","metadata":{"type":"direct_query","category":"handlers","priority":90}}
{"text":"<|user|>Is this approach correct for MCP: Outcomes Over Operations?\n\nget_user(email), then get_orders(userId), then get_status(orderId) - 3 round trips<|assistant|>No, this violates the guideline. The correct approach is: Design MCP tools for complete workflows, not atomic API operations. One tool should equal one 'agent story' - a complete task the agent wants to accomplish. Don't make the agent orchestrate multiple tool calls when you can bundle the logic server-side. Agents are slow and expensive orchestrators; if you know the workflow, implement it in code.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>Is this approach correct for MCP: Instructions Are Context?\n\nExample with 2 tags when you want 10+ tags<|assistant|>No, this violates the guideline. The correct approach is: Document your MCP server and all tools thoroughly - undocumented tools force agents to guess. Use the server's instructions field for high-level guidance. Examples are contracts: agents will follow example patterns literally (e.g., example with 2 tags = always 2 tags). Errors are prompts: helpful error messages guide recovery and become part of the next prompt.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>I need guidance on typescript strict mode & type imports. What should I know?<|assistant|>Here's the guideline: Always use TypeScript strict mode. Use type-only imports for types: `import type { ... } from '...'`. Prefer interfaces for contracts and types for data shapes. Use discriminated unions for query parameters. Never use `any` - use `unknown` with type guards instead.<|end|>","metadata":{"type":"contextual_query","category":"typescript","priority":90}}
{"text":"<|user|>I need guidance on graceful degradation pattern. What should I know?<|assistant|>Here's the guideline: Non-critical features should fail gracefully without breaking core functionality. Use `safeAsync()` wrapper with default fallback values. Examples: auto-tagging, red flag detection, duplicate checking. Critical operations (permissions, validation) should fail-fast.<|end|>","metadata":{"type":"contextual_query","category":"error-handling","priority":85}}
{"text":"<|user|>I need guidance on always-use-typescript-strict. What should I know?<|assistant|>Here's the guideline: Always use TypeScript strict mode for all new files. Enable noImplicitAny and strictNullChecks.<|end|>","metadata":{"type":"contextual_query","category":"code_style","priority":100}}
{"text":"<|user|>Is this approach correct for MCP: Flatten Tool Arguments?\n\nemail: string, include_cancelled: boolean, limit: number<|assistant|>Yes, this follows the guideline. Use top-level primitive arguments, not nested objects or config dictionaries. Use Literal types or enums for constrained choices. Avoid tightly coupled arguments where valid values for one depend on another. LLMs struggle with complex argument structures and some clients serialize objects incorrectly.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>What is the guideline for \"Class and Function Naming\"?<|assistant|>Use PascalCase for classes: `PermissionService`, `SQLiteStorageAdapter`. Use camelCase for functions: `extractAddParams()`, `validateEmbedding()`. Type guard functions use `is` prefix: `isString()`, `isScopeType()`, `isEntryType()`.<|end|>","metadata":{"type":"direct_query","category":"naming","priority":85}}
{"text":"<|user|>I need guidance on mcp: curate ruthlessly. What should I know?<|assistant|>Here's the guideline: Start with what works, then tear it down to essentials. Don't just wrap REST APIs as MCP tools - that violates every design principle. Name tools for the agent (clear intent), not for developers (technical accuracy). Remove tools that aren't essential; each additional tool degrades performance.<|end|>","metadata":{"type":"contextual_query","category":"mcp-design","priority":90}}
{"text":"<|user|>What is the guideline for \"File Naming Convention\"?<|assistant|>Use kebab-case for all file names with domain-specific suffixes: `{domain}.{layer}.ts`. Examples: `knowledge.handler.ts`, `embedding.service.ts`, `sqlite.adapter.ts`, `permission.service.ts`. Test files use `.test.ts` suffix.<|end|>","metadata":{"type":"direct_query","category":"naming","priority":85}}
{"text":"<|user|>What is the guideline for \"typescript-strict-mode\"?<|assistant|>Enable TypeScript strict mode in all projects<|end|>","metadata":{"type":"direct_query","category":"code_style","priority":90}}
{"text":"<|user|>What is the guideline for \"MCP: Instructions Are Context\"?<|assistant|>Document your MCP server and all tools thoroughly - undocumented tools force agents to guess. Use the server's instructions field for high-level guidance. Examples are contracts: agents will follow example patterns literally (e.g., example with 2 tags = always 2 tags). Errors are prompts: helpful error messages guide recovery and become part of the next prompt.<|end|>","metadata":{"type":"direct_query","category":"mcp-design","priority":85}}
{"text":"<|user|>How should I handle mcp: instructions are context?<|assistant|>Document your MCP server and all tools thoroughly - undocumented tools force agents to guess. Use the server's instructions field for high-level guidance. Examples are contracts: agents will follow example patterns literally (e.g., example with 2 tags = always 2 tags). Errors are prompts: helpful error messages guide recovery and become part of the next prompt.<|end|>","metadata":{"type":"validation_query","category":"mcp-design","priority":85}}
{"text":"<|user|>I need guidance on transaction safety pattern. What should I know?<|assistant|>Here's the guideline: Wrap multi-entry operations in `transactionWithDb()`. For SQLite: promises must resolve synchronously within transaction. For PostgreSQL: automatic retry on transient errors. Re-check for existing entries inside transaction for TOCTOU safety (Bug #30).<|end|>","metadata":{"type":"contextual_query","category":"database","priority":90}}
{"text":"<|user|>Is this approach correct for MCP: Flatten Tool Arguments?\n\nArguments where valid values depend on other argument values<|assistant|>No, this violates the guideline. The correct approach is: Use top-level primitive arguments, not nested objects or config dictionaries. Use Literal types or enums for constrained choices. Avoid tightly coupled arguments where valid values for one depend on another. LLMs struggle with complex argument structures and some clients serialize objects incorrectly.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>I need guidance on handler context injection. What should I know?<|assistant|>Here's the guideline: All handlers must accept `AppContext` as the first parameter for dependency injection. Use `contextHandler` in descriptors (not legacy `handler`). Access services via `context.services.*`, repos via `context.repos.*`.<|end|>","metadata":{"type":"contextual_query","category":"handlers","priority":90}}
{"text":"<|user|>I need guidance on permission check pattern. What should I know?<|assistant|>Here's the guideline: Check permissions before any data access (Bug #338). Use `requirePermission()` for single entries, `requirePermissionBatch()` for bulk operations. Always pass explicit `entryId` (or null for type-level checks) per Bug #340.<|end|>","metadata":{"type":"contextual_query","category":"security","priority":95}}
{"text":"<|user|>I need guidance on mcp: outcomes over operations. What should I know?<|assistant|>Here's the guideline: Design MCP tools for complete workflows, not atomic API operations. One tool should equal one 'agent story' - a complete task the agent wants to accomplish. Don't make the agent orchestrate multiple tool calls when you can bundle the logic server-side. Agents are slow and expensive orchestrators; if you know the workflow, implement it in code.<|end|>","metadata":{"type":"contextual_query","category":"mcp-design","priority":95}}
{"text":"<|user|>How should I handle mcp: understand agent limitations?<|assistant|>Agents differ from humans on three dimensions: 1) Discovery is expensive (happens every handshake, not once), 2) Iteration is slow (each call sends full history, costs tokens), 3) Context is limited (200k tokens max, no long-term memory). Design for these constraints, not human developer workflows.<|end|>","metadata":{"type":"validation_query","category":"mcp-design","priority":90}}
{"text":"<|user|>How should I handle graceful degradation pattern?<|assistant|>Non-critical features should fail gracefully without breaking core functionality. Use `safeAsync()` wrapper with default fallback values. Examples: auto-tagging, red flag detection, duplicate checking. Critical operations (permissions, validation) should fail-fast.<|end|>","metadata":{"type":"validation_query","category":"error-handling","priority":85}}
{"text":"<|user|>Is this approach correct for MCP: Understand Agent Limitations?\n\nAssuming agent will 'figure out' the right sequence<|assistant|>No, this violates the guideline. The correct approach is: Agents differ from humans on three dimensions: 1) Discovery is expensive (happens every handshake, not once), 2) Iteration is slow (each call sends full history, costs tokens), 3) Context is limited (200k tokens max, no long-term memory). Design for these constraints, not human developer workflows.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>Is this approach correct for MCP: Flatten Tool Arguments?\n\nformat: Literal['basic', 'detailed', 'json']<|assistant|>Yes, this follows the guideline. Use top-level primitive arguments, not nested objects or config dictionaries. Use Literal types or enums for constrained choices. Avoid tightly coupled arguments where valid values for one depend on another. LLMs struggle with complex argument structures and some clients serialize objects incorrectly.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>Is this approach correct for MCP: Instructions Are Context?\n\nExamples showing diverse patterns, not just one case<|assistant|>Yes, this follows the guideline. Document your MCP server and all tools thoroughly - undocumented tools force agents to guess. Use the server's instructions field for high-level guidance. Examples are contracts: agents will follow example patterns literally (e.g., example with 2 tags = always 2 tags). Errors are prompts: helpful error messages guide recovery and become part of the next prompt.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>How should I handle type guard validation?<|assistant|>Use runtime type guards for all parameter validation. Use `getRequiredParam(params, key, typeGuard)` and `getOptionalParam(params, key, typeGuard)` for safe extraction. Never cast types without validation.<|end|>","metadata":{"type":"validation_query","category":"validation","priority":90}}
{"text":"<|user|>Is this approach correct for Type Guard Validation?\n\nconst title = getRequiredParam(params, 'title', isString);<|assistant|>Yes, this follows the guideline. Use runtime type guards for all parameter validation. Use `getRequiredParam(params, key, typeGuard)` and `getOptionalParam(params, key, typeGuard)` for safe extraction. Never cast types without validation.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>How should I handle handler context injection?<|assistant|>All handlers must accept `AppContext` as the first parameter for dependency injection. Use `contextHandler` in descriptors (not legacy `handler`). Access services via `context.services.*`, repos via `context.repos.*`.<|end|>","metadata":{"type":"validation_query","category":"handlers","priority":90}}
{"text":"<|user|>Is this approach correct for Type Guard Validation?\n\nconst title = params.title as string;<|assistant|>No, this violates the guideline. The correct approach is: Use runtime type guards for all parameter validation. Use `getRequiredParam(params, key, typeGuard)` and `getOptionalParam(params, key, typeGuard)` for safe extraction. Never cast types without validation.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>How should I handle error handling pattern?<|assistant|>Use custom `AgentMemoryError` with namespaced error codes (E1000-E1999 for validation, E2000-E2999 for resources). Create errors with factory functions: `createValidationError()`, `createNotFoundError()`, `createPermissionError()`. Sanitize error messages in production to prevent info disclosure.<|end|>","metadata":{"type":"validation_query","category":"error-handling","priority":90}}
{"text":"<|user|>Is this approach correct for MCP: Flatten Tool Arguments?\n\nconfig: { format: string, filters: { ... }, options: { ... } }<|assistant|>No, this violates the guideline. The correct approach is: Use top-level primitive arguments, not nested objects or config dictionaries. Use Literal types or enums for constrained choices. Avoid tightly coupled arguments where valid values for one depend on another. LLMs struggle with complex argument structures and some clients serialize objects incorrectly.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>What is the guideline for \"Type Guard Validation\"?<|assistant|>Use runtime type guards for all parameter validation. Use `getRequiredParam(params, key, typeGuard)` and `getOptionalParam(params, key, typeGuard)` for safe extraction. Never cast types without validation.<|end|>","metadata":{"type":"direct_query","category":"validation","priority":90}}
{"text":"<|user|>Is this approach correct for Error Handling Pattern?\n\nthrow new Error('validation failed');<|assistant|>No, this violates the guideline. The correct approach is: Use custom `AgentMemoryError` with namespaced error codes (E1000-E1999 for validation, E2000-E2999 for resources). Create errors with factory functions: `createValidationError()`, `createNotFoundError()`, `createPermissionError()`. Sanitize error messages in production to prevent info disclosure.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>What is the guideline for \"Graceful Degradation Pattern\"?<|assistant|>Non-critical features should fail gracefully without breaking core functionality. Use `safeAsync()` wrapper with default fallback values. Examples: auto-tagging, red flag detection, duplicate checking. Critical operations (permissions, validation) should fail-fast.<|end|>","metadata":{"type":"direct_query","category":"error-handling","priority":85}}
{"text":"<|user|>What is the guideline for \"MCP: Respect the Token Budget\"?<|assistant|>Keep total tools per agent under 50. Each tool's schema + description consumes context on every handshake. With 200k token context and 800 tools, each tool gets ~250 tokens total - including schema. Prefer 5-15 tools when possible. Token budget is the only hard constraint - violating it makes your server unusable.<|end|>","metadata":{"type":"direct_query","category":"mcp-design","priority":95}}
{"text":"<|user|>How should I handle mcp: curate ruthlessly?<|assistant|>Start with what works, then tear it down to essentials. Don't just wrap REST APIs as MCP tools - that violates every design principle. Name tools for the agent (clear intent), not for developers (technical accuracy). Remove tools that aren't essential; each additional tool degrades performance.<|end|>","metadata":{"type":"validation_query","category":"mcp-design","priority":90}}
{"text":"<|user|>How should I handle always-wrap-db-changes-in-transaction?<|assistant|>Always wrap related database changes in a transaction block<|end|>","metadata":{"type":"validation_query","category":"architecture","priority":100}}
{"text":"<|user|>Is this approach correct for Handler Context Injection?\n\nasync handler(params: Record<string, unknown>) { ... }<|assistant|>No, this violates the guideline. The correct approach is: All handlers must accept `AppContext` as the first parameter for dependency injection. Use `contextHandler` in descriptors (not legacy `handler`). Access services via `context.services.*`, repos via `context.repos.*`.<|end|>","metadata":{"type":"example_validation","exampleType":"bad"}}
{"text":"<|user|>Is this approach correct for MCP: Curate Ruthlessly?\n\nTool names like 'track_order' not 'GET_orders_by_id'<|assistant|>Yes, this follows the guideline. Start with what works, then tear it down to essentials. Don't just wrap REST APIs as MCP tools - that violates every design principle. Name tools for the agent (clear intent), not for developers (technical accuracy). Remove tools that aren't essential; each additional tool degrades performance.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>What is the guideline for \"Permission Check Pattern\"?<|assistant|>Check permissions before any data access (Bug #338). Use `requirePermission()` for single entries, `requirePermissionBatch()` for bulk operations. Always pass explicit `entryId` (or null for type-level checks) per Bug #340.<|end|>","metadata":{"type":"direct_query","category":"security","priority":95}}
{"text":"<|user|>Is this approach correct for MCP: Respect the Token Budget?\n\nProgressive disclosure via describe/list meta-tools<|assistant|>Yes, this follows the guideline. Keep total tools per agent under 50. Each tool's schema + description consumes context on every handshake. With 200k token context and 800 tools, each tool gets ~250 tokens total - including schema. Prefer 5-15 tools when possible. Token budget is the only hard constraint - violating it makes your server unusable.<|end|>","metadata":{"type":"example_validation","exampleType":"good"}}
{"text":"<|user|>What is the guideline for \"Error Handling Pattern\"?<|assistant|>Use custom `AgentMemoryError` with namespaced error codes (E1000-E1999 for validation, E2000-E2999 for resources). Create errors with factory functions: `createValidationError()`, `createNotFoundError()`, `createPermissionError()`. Sanitize error messages in production to prevent info disclosure.<|end|>","metadata":{"type":"direct_query","category":"error-handling","priority":90}}