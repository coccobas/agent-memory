/**
 * Semantic Stage
 *
 * Performs vector similarity search when the strategy is 'semantic' or 'hybrid'.
 * Generates query embeddings and populates semanticScores for use in scoring.
 *
 * Uses injected dependencies for embedding service and vector service.
 *
 * Pipeline Context Extensions:
 * - Requires `searchStrategy` in PipelineContext (from strategy stage)
 * - Adds `queryEmbedding?: number[]` to PipelineContext for downstream use
 * - Populates `semanticScores` map with entry IDs and similarity scores
 */

import type { PipelineContext } from '../pipeline.js';
import type { SearchStrategy } from './strategy.js';
import { AgentMemoryError, ErrorCodes } from '../../../core/errors.js';

/**
 * Extended pipeline context with semantic search results
 */
export interface SemanticStageContext extends PipelineContext {
  /**
   * The resolved search strategy for this query.
   * Determines whether semantic search is applied.
   */
  searchStrategy: SearchStrategy;

  /**
   * Query embedding generated by the embedding service.
   * Used for vector similarity calculations in scoring.
   */
  queryEmbedding?: number[];
}

/**
 * Async semantic stage - performs vector similarity search for semantic/hybrid modes
 *
 * Uses the embeddingService from dependencies if available.
 * Skips gracefully if service not available or strategy doesn't require semantic.
 *
 * Strategy selection:
 * 1. If searchStrategy is not 'semantic' or 'hybrid' -> pass through
 * 2. If no search query -> pass through
 * 3. If embedding service unavailable -> pass through with debug log
 * 4. Otherwise -> generate embedding and prepare semantic scores
 *
 * @param ctx Pipeline context with searchStrategy and search query
 * @returns Updated context with semanticScores and queryEmbedding
 */
export async function semanticStageAsync(ctx: PipelineContext): Promise<PipelineContext> {
  // Cast to access searchStrategy
  const semanticCtx = ctx as SemanticStageContext;
  const { search, deps } = ctx;
  const searchStrategy = semanticCtx.searchStrategy;

  // Skip if not semantic/hybrid mode or no search query
  if (searchStrategy !== 'semantic' && searchStrategy !== 'hybrid') {
    return ctx;
  }

  if (!search) {
    return ctx;
  }

  // Check if embedding service is available
  if (!deps.embeddingService || !deps.embeddingService.isAvailable()) {
    if (deps.logger && deps.perfLog) {
      deps.logger.debug({}, 'semantic stage skipped: embedding service unavailable');
    }
    return ctx;
  }

  try {
    const startMs = Date.now();
    const { types, limit } = ctx;

    // Check for HyDE embeddings from rewrite stage
    const searchQueries = (ctx as { searchQueries?: Array<{ text: string; embedding?: number[]; weight: number; source: string }> }).searchQueries;
    const hydeQueries = searchQueries?.filter(q => q.source === 'hyde' && q.embedding) ?? [];

    // 1. Generate query embedding (use first HyDE embedding if available, otherwise embed original)
    let queryEmbedding: number[];
    let embeddingsToSearch: Array<{ embedding: number[]; weight: number }> = [];

    if (hydeQueries.length > 0) {
      // Use HyDE embeddings for semantic search
      embeddingsToSearch = hydeQueries.map(q => ({
        embedding: q.embedding!,
        weight: q.weight,
      }));
      // Use first HyDE embedding as the primary query embedding
      queryEmbedding = hydeQueries[0]!.embedding!;

      if (deps.logger && deps.perfLog) {
        deps.logger.debug(
          { hydeCount: hydeQueries.length },
          'semantic stage using HyDE embeddings'
        );
      }
    } else {
      // Fall back to embedding the original query
      const queryResult = await deps.embeddingService.embed(search);
      queryEmbedding = queryResult.embedding;
      embeddingsToSearch = [{ embedding: queryResult.embedding, weight: 1.0 }];
    }

    // 2. Search vector store for similar entries using all embeddings
    const semanticScores = new Map<string, number>();

    if (deps.vectorService && deps.vectorService.isAvailable()) {
      // Convert query types to entry types (e.g., 'tools' -> 'tool')
      const entryTypes = types.map((t) => {
        if (t === 'tools') return 'tool';
        if (t === 'guidelines') return 'guideline';
        if (t === 'experiences') return 'experience';
        return 'knowledge';
      });

      // Search with each embedding and combine results (max score wins)
      let totalResults = 0;
      for (const { embedding, weight } of embeddingsToSearch) {
        const results = await deps.vectorService.searchSimilar(
          embedding,
          entryTypes,
          limit * 3 // Fetch more candidates for scoring stage to filter
        );

        for (const r of results) {
          const weightedScore = r.score * weight;
          const existing = semanticScores.get(r.entryId) ?? 0;
          // Take the max score across all embeddings
          semanticScores.set(r.entryId, Math.max(existing, weightedScore));
        }
        totalResults += results.length;
      }

      if (deps.logger && deps.perfLog) {
        deps.logger.debug(
          {
            queryLength: search.length,
            embeddingDim: queryEmbedding.length,
            vectorResults: totalResults,
            uniqueResults: semanticScores.size,
            hydeCount: hydeQueries.length,
            timeMs: Date.now() - startMs,
          },
          'semantic stage completed with vector search'
        );
      }
    } else {
      // Vector service not available - just store embedding for potential use in reranking
      if (deps.logger && deps.perfLog) {
        deps.logger.debug(
          {
            queryLength: search.length,
            embeddingDim: queryEmbedding.length,
            timeMs: Date.now() - startMs,
          },
          'semantic stage completed (no vector service)'
        );
      }
    }

    return {
      ...ctx,
      semanticScores,
      queryEmbedding,
    } as SemanticStageContext;
  } catch (error) {
    // Classify error and log appropriately
    if (deps.logger) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorCode = error instanceof AgentMemoryError ? error.code : undefined;

      // Expected errors (embeddings disabled) - log at debug level
      if (errorCode === ErrorCodes.EMBEDDING_DISABLED) {
        deps.logger.debug(
          { error: errorMessage },
          'semantic stage skipped: embeddings disabled'
        );
      }
      // Transient errors (network, timeout) - log at warn level
      else if (
        errorCode === ErrorCodes.NETWORK_ERROR ||
        errorCode === ErrorCodes.TIMEOUT ||
        errorCode === ErrorCodes.SERVICE_UNAVAILABLE
      ) {
        deps.logger.warn(
          { error: errorMessage, errorCode, retriable: true },
          'semantic stage failed with transient error - continuing without semantic scores'
        );
      }
      // Unexpected errors - log at warn level with full context
      else {
        deps.logger.warn(
          {
            error: errorMessage,
            errorCode,
            errorType: error?.constructor?.name,
            search: search?.substring(0, 100), // Truncate for privacy
          },
          'semantic stage failed unexpectedly - continuing without semantic scores'
        );
      }
    }
    return ctx;
  }
}
