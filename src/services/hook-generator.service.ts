/**
 * Hook Generator Service
 *
 * Generates IDE-specific verification hooks and configuration files
 * for Claude Code and Cursor.
 */

import * as fs from 'fs';
import * as path from 'path';
import { getCriticalGuidelinesForScope } from './critical-guidelines.service.js';
import { createComponentLogger } from '../utils/logger.js';

const logger = createComponentLogger('hook-generator');

// =============================================================================
// TYPES
// =============================================================================

export type SupportedIDE = 'claude' | 'cursor' | 'vscode';

export interface HookConfig {
  ide: SupportedIDE;
  projectPath: string;
  projectId?: string;
  sessionId?: string;
}

export interface GeneratedHook {
  filePath: string;
  content: string;
  instructions: string;
}

export interface HookGenerationResult {
  success: boolean;
  hooks: GeneratedHook[];
  message: string;
}

// =============================================================================
// CLAUDE CODE HOOKS
// =============================================================================

/**
 * Generate the Claude Code PreToolUse hook script (blocking verification)
 */
export function generateClaudeCodeHookScript(params?: { projectId?: string }): string {
  const projectId = params?.projectId || '';
  return `#!/bin/bash
# Claude Code PreToolUse hook
# Auto-generated by Agent Memory
#
# Purpose:
# - Enforce critical guidelines BEFORE running Edit/Write/Bash (blocks on violations)
# - Does not rely on the model remembering to call memory_verify

set -euo pipefail

# Exit early if no stdin (Claude provides hook JSON on stdin)
if [ -t 0 ]; then
  exit 0
fi

# Stable default DB location (can be overridden by env)
if [ -z "\${AGENT_MEMORY_DB_PATH:-}" ]; then
  export AGENT_MEMORY_DB_PATH="\${HOME}/.agent-memory/memory.db"
fi

# Prefer a locally installed binary; fallback to npx.
if command -v agent-memory >/dev/null 2>&1; then
  AM_CMD=(agent-memory)
else
  AM_CMD=(npx -y agent-memory@latest)
fi

AGENT_ID="\${AGENT_ID:-claude-code}"

exec "\${AM_CMD[@]}" hook pretooluse${projectId ? ` --project-id "${projectId}"` : ''} --agent-id "\${AGENT_ID}"
`;
}

/**
 * Generate Claude Code settings.json hook configuration
 */
export function generateClaudeCodeSettings(projectPath: string): string {
  const preToolUsePath = path.join(projectPath, '.claude', 'hooks', 'pretooluse.sh');
  const stopPath = path.join(projectPath, '.claude', 'hooks', 'stop.sh');
  const userPromptSubmitPath = path.join(projectPath, '.claude', 'hooks', 'userpromptsubmit.sh');
  const sessionEndPath = path.join(projectPath, '.claude', 'hooks', 'session-end.sh');

  return JSON.stringify(
    {
      hooks: {
        PreToolUse: [
          {
            matcher: 'Edit|Write|Bash',
            hooks: [
              {
                type: 'command',
                command: preToolUsePath,
              },
            ],
          },
        ],
        Stop: [
          {
            hooks: [
              {
                type: 'command',
                command: stopPath,
              },
            ],
          },
        ],
        UserPromptSubmit: [
          {
            hooks: [
              {
                type: 'command',
                command: userPromptSubmitPath,
              },
            ],
          },
        ],
        SessionEnd: [
          {
            hooks: [
              {
                type: 'command',
                command: sessionEndPath,
              },
            ],
          },
        ],
      },
    },
    null,
    2
  );
}

/**
 * Generate the Claude Code Stop hook script (blocking end-of-session review)
 */
export function generateClaudeCodeStopHookScript(params?: { projectId?: string }): string {
  const projectId = params?.projectId || '';
  return `#!/bin/bash
# Claude Code Stop hook
# Auto-generated by Agent Memory
#
# Purpose:
# - Block stopping until end-of-session observe+review is done (or explicitly suspended)
# - Ensures no information is lost due to missed tool calls

set -euo pipefail

if [ -t 0 ]; then
  exit 0
fi

if [ -z "\${AGENT_MEMORY_DB_PATH:-}" ]; then
  export AGENT_MEMORY_DB_PATH="\${HOME}/.agent-memory/memory.db"
fi

if command -v agent-memory >/dev/null 2>&1; then
  AM_CMD=(agent-memory)
else
  AM_CMD=(npx -y agent-memory@latest)
fi

AGENT_ID="\${AGENT_ID:-claude-code}"

exec "\${AM_CMD[@]}" hook stop${projectId ? ` --project-id "${projectId}"` : ''} --agent-id "\${AGENT_ID}"
`;
}

/**
 * Generate the Claude Code UserPromptSubmit hook script (session controls)
 */
export function generateClaudeCodeUserPromptSubmitHookScript(params?: { projectId?: string }): string {
  const projectId = params?.projectId || '';
  return `#!/bin/bash
# Claude Code UserPromptSubmit hook
# Auto-generated by Agent Memory
#
# Purpose:
# - Allow per-session review controls via commands like:
#   - !am review off / on
#   - !am review done
#   - !am status

set -euo pipefail

if [ -t 0 ]; then
  exit 0
fi

if [ -z "\${AGENT_MEMORY_DB_PATH:-}" ]; then
  export AGENT_MEMORY_DB_PATH="\${HOME}/.agent-memory/memory.db"
fi

if command -v agent-memory >/dev/null 2>&1; then
  AM_CMD=(agent-memory)
else
  AM_CMD=(npx -y agent-memory@latest)
fi

exec "\${AM_CMD[@]}" hook userpromptsubmit${projectId ? ` --project-id "${projectId}"` : ''}
`;
}

/**
 * Generate the Claude Code SessionEnd hook script (transcript ingestion)
 */
export function generateClaudeCodeSessionEndHookScript(params?: { projectId?: string }): string {
  const projectId = params?.projectId || '';
  return `#!/bin/bash
# Claude Code SessionEnd hook
# Auto-generated by Agent Memory
#
# Purpose:
# - Ingest Claude transcript into Agent Memory conversation history
# - Prevent "lost information" even if the agent never called memory tools

set -euo pipefail

if [ -t 0 ]; then
  exit 0
fi

if [ -z "\${AGENT_MEMORY_DB_PATH:-}" ]; then
  export AGENT_MEMORY_DB_PATH="\${HOME}/.agent-memory/memory.db"
fi

if command -v agent-memory >/dev/null 2>&1; then
  AM_CMD=(agent-memory)
else
  AM_CMD=(npx -y agent-memory@latest)
fi

AGENT_ID="\${AGENT_ID:-claude-code}"

exec "\${AM_CMD[@]}" hook session-end${projectId ? ` --project-id "${projectId}"` : ''} --agent-id "\${AGENT_ID}"
`;
}

/**
 * Generate installation instructions for Claude Code hooks
 */
export function generateClaudeCodeInstructions(projectPath: string): string {
  return `
# Claude Code Hook Installation (Enforcement + Transcript Ingestion + Blocking Review)

## Automatic Installation

If Agent Memory is configured as an MCP server in Claude Code, run the MCP tool:

\`\`\`json
{
  "name": "memory_hook",
  "arguments": { "action": "install", "ide": "claude", "projectPath": "${projectPath}" }
}
\`\`\`

## Manual Installation

1. Create the hooks directory:
   \`\`\`bash
   mkdir -p "${path.join(projectPath, '.claude', 'hooks')}"
   \`\`\`

2. Copy the hook scripts to:
   - \`${path.join(projectPath, '.claude', 'hooks', 'pretooluse.sh')}\`
   - \`${path.join(projectPath, '.claude', 'hooks', 'stop.sh')}\`
   - \`${path.join(projectPath, '.claude', 'hooks', 'userpromptsubmit.sh')}\`
   - \`${path.join(projectPath, '.claude', 'hooks', 'session-end.sh')}\`

3. Make it executable:
\`\`\`bash
   chmod +x "${path.join(projectPath, '.claude', 'hooks', 'pretooluse.sh')}"
   chmod +x "${path.join(projectPath, '.claude', 'hooks', 'stop.sh')}"
   chmod +x "${path.join(projectPath, '.claude', 'hooks', 'userpromptsubmit.sh')}"
   chmod +x "${path.join(projectPath, '.claude', 'hooks', 'session-end.sh')}"
\`\`\`

4. Add the hook configuration to your \`.claude/settings.json\`:
   \`\`\`json
   {
     "hooks": {
       "PreToolUse": [
         {
           "matcher": "Edit|Write|Bash",
           "hooks": [
             { "type": "command", "command": "${path.join(
               projectPath,
               '.claude',
               'hooks',
               'pretooluse.sh'
             )}" }
           ]
         }
       ],
       "Stop": [
         {
           "hooks": [
             { "type": "command", "command": "${path.join(projectPath, '.claude', 'hooks', 'stop.sh')}" }
           ]
         }
       ],
       "UserPromptSubmit": [
         {
           "hooks": [
             { "type": "command", "command": "${path.join(
               projectPath,
               '.claude',
               'hooks',
               'userpromptsubmit.sh'
             )}" }
           ]
         }
       ],
       "SessionEnd": [
         {
           "hooks": [
             { "type": "command", "command": "${path.join(
               projectPath,
               '.claude',
               'hooks',
               'session-end.sh'
             )}" }
           ]
         }
       ]
     }
   }
   \`\`\`

## How It Works

- **PreToolUse** runs before Edit/Write/Bash and can block unsafe actions deterministically.
- **Stop** blocks ending the session until an observe+review step is completed (or explicitly suspended for the session).
- **UserPromptSubmit** lets you control review enforcement per session with commands:
  - \`!am review off\` / \`!am review on\`
  - \`!am review done\`
  - \`!am status\`
- **SessionEnd** ingests the full transcript into Agent Memory so information is not lost even if the agent forgets to store memories.
`;
}

// =============================================================================
// CURSOR RULES
// =============================================================================

/**
 * Generate Cursor rules file with critical guidelines
 */
export function generateCursorRulesFile(
  projectId: string | null,
  sessionId?: string | null
): string {
  const guidelines = getCriticalGuidelinesForScope(projectId, sessionId);

  if (guidelines.length === 0) {
    return `# Critical Guidelines (Auto-synced from Agent Memory)

> No critical guidelines found. Guidelines with priority >= 90 will appear here.
> Last synced: ${new Date().toISOString()}
`;
  }

  let content = `# Critical Guidelines (Auto-synced from Agent Memory)

## MUST FOLLOW - Priority 90+

These guidelines are critical and must be followed in all interactions.
Call \`memory_verify pre_check\` before file modifications.

`;

  for (const guideline of guidelines) {
    content += `### ${guideline.name} (Priority: ${guideline.priority})\n\n`;
    content += `${guideline.content}\n\n`;

    if (guideline.rationale) {
      content += `**Rationale:** ${guideline.rationale}\n\n`;
    }

    if (guideline.examples) {
      if (guideline.examples.bad && guideline.examples.bad.length > 0) {
        content += `**Bad examples:**\n`;
        for (const bad of guideline.examples.bad) {
          content += `- \`${bad}\`\n`;
        }
        content += '\n';
      }

      if (guideline.examples.good && guideline.examples.good.length > 0) {
        content += `**Good examples:**\n`;
        for (const good of guideline.examples.good) {
          content += `- \`${good}\`\n`;
        }
        content += '\n';
      }
    }

    content += '---\n\n';
  }

  content += `> Last synced: ${new Date().toISOString()}\n`;
  content += `> Total critical guidelines: ${guidelines.length}\n`;

  return content;
}

/**
 * Generate installation instructions for Cursor rules
 */
export function generateCursorInstructions(projectPath: string): string {
  return `
# Cursor Rules Sync

## Automatic Sync

Run the following command to sync critical guidelines to Cursor:

\`\`\`bash
npx agent-memory-client sync-critical --ide=cursor --project="${projectPath}"
\`\`\`

## Manual Setup

1. The sync creates/updates this file:
   \`${path.join(projectPath, '.cursor', 'rules', 'critical-guidelines.md')}\`

2. Cursor will automatically include these rules in its context.

## Keeping Rules Updated

- Re-run the sync command whenever critical guidelines change
- Consider adding the sync to your project's pre-commit hooks
- Or set up a scheduled task to sync periodically
`;
}

// =============================================================================
// MAIN GENERATION FUNCTIONS
// =============================================================================

/**
 * Generate all hooks for a specific IDE
 */
export function generateHooks(config: HookConfig): HookGenerationResult {
  const hooks: GeneratedHook[] = [];

  try {
    switch (config.ide) {
      case 'claude': {
        // PreToolUse (blocking) hook script
        hooks.push({
          filePath: path.join(config.projectPath, '.claude', 'hooks', 'pretooluse.sh'),
          content: generateClaudeCodeHookScript({ projectId: config.projectId }),
          instructions: generateClaudeCodeInstructions(config.projectPath),
        });

        // Stop (blocking review) hook script
        hooks.push({
          filePath: path.join(config.projectPath, '.claude', 'hooks', 'stop.sh'),
          content: generateClaudeCodeStopHookScript({ projectId: config.projectId }),
          instructions: generateClaudeCodeInstructions(config.projectPath),
        });

        // UserPromptSubmit (session controls) hook script
        hooks.push({
          filePath: path.join(config.projectPath, '.claude', 'hooks', 'userpromptsubmit.sh'),
          content: generateClaudeCodeUserPromptSubmitHookScript({ projectId: config.projectId }),
          instructions: generateClaudeCodeInstructions(config.projectPath),
        });

        // SessionEnd (ingestion) hook script
        hooks.push({
          filePath: path.join(config.projectPath, '.claude', 'hooks', 'session-end.sh'),
          content: generateClaudeCodeSessionEndHookScript({ projectId: config.projectId }),
          instructions: generateClaudeCodeInstructions(config.projectPath),
        });

        // Project settings
        hooks.push({
          filePath: path.join(config.projectPath, '.claude', 'settings.json'),
          content: generateClaudeCodeSettings(config.projectPath),
          instructions: 'Claude Code hooks configuration file',
        });

        break;
      }

      case 'cursor': {
        // Generate rules file
        hooks.push({
          filePath: path.join(config.projectPath, '.cursor', 'rules', 'critical-guidelines.md'),
          content: generateCursorRulesFile(config.projectId ?? null, config.sessionId),
          instructions: generateCursorInstructions(config.projectPath),
        });

        break;
      }

      case 'vscode': {
        // VSCode doesn't have native hooks, but we can provide rules
        hooks.push({
          filePath: path.join(config.projectPath, '.vscode', 'critical-guidelines.md'),
          content: generateCursorRulesFile(config.projectId ?? null, config.sessionId),
          instructions: 'VSCode does not support native hooks. This file contains critical guidelines for reference.',
        });

        break;
      }

      default:
        return {
          success: false,
          hooks: [],
          message: `Unsupported IDE: ${config.ide}`,
        };
    }

    logger.info({ ide: config.ide, hookCount: hooks.length }, 'Generated hooks');

    return {
      success: true,
      hooks,
      message: `Generated ${hooks.length} hook(s) for ${config.ide}`,
    };
  } catch (error) {
    logger.error({ error, config }, 'Failed to generate hooks');
    return {
      success: false,
      hooks: [],
      message: `Failed to generate hooks: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}

/**
 * Install generated hooks to the filesystem
 */
export function installHooks(hooks: GeneratedHook[]): { success: boolean; installed: string[]; errors: string[] } {
  const installed: string[] = [];
  const errors: string[] = [];

  for (const hook of hooks) {
    try {
      // Create directory if it doesn't exist
      const dir = path.dirname(hook.filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Write the file
      fs.writeFileSync(hook.filePath, hook.content, 'utf-8');

      // Make shell scripts executable
      if (hook.filePath.endsWith('.sh')) {
        fs.chmodSync(hook.filePath, '755');
      }

      installed.push(hook.filePath);
      logger.info({ filePath: hook.filePath }, 'Installed hook');
    } catch (error) {
      const errorMessage = `Failed to install ${hook.filePath}: ${error instanceof Error ? error.message : String(error)}`;
      errors.push(errorMessage);
      logger.error({ error, filePath: hook.filePath }, 'Failed to install hook');
    }
  }

  return {
    success: errors.length === 0,
    installed,
    errors,
  };
}

/**
 * Get hook status for a project
 */
export function getHookStatus(
  projectPath: string,
  ide: SupportedIDE
): { installed: boolean; files: { path: string; exists: boolean }[] } {
  const files: { path: string; exists: boolean }[] = [];

  switch (ide) {
    case 'claude': {
      const preToolUseScript = path.join(projectPath, '.claude', 'hooks', 'pretooluse.sh');
      const stopScript = path.join(projectPath, '.claude', 'hooks', 'stop.sh');
      const userPromptSubmitScript = path.join(projectPath, '.claude', 'hooks', 'userpromptsubmit.sh');
      const sessionEndScript = path.join(projectPath, '.claude', 'hooks', 'session-end.sh');
      const settings = path.join(projectPath, '.claude', 'settings.json');
      files.push(
        { path: preToolUseScript, exists: fs.existsSync(preToolUseScript) },
        { path: stopScript, exists: fs.existsSync(stopScript) },
        { path: userPromptSubmitScript, exists: fs.existsSync(userPromptSubmitScript) },
        { path: sessionEndScript, exists: fs.existsSync(sessionEndScript) },
        { path: settings, exists: fs.existsSync(settings) }
      );
      break;
    }

    case 'cursor': {
      const rulesFile = path.join(projectPath, '.cursor', 'rules', 'critical-guidelines.md');
      files.push({ path: rulesFile, exists: fs.existsSync(rulesFile) });
      break;
    }

    case 'vscode': {
      const guidelinesFile = path.join(projectPath, '.vscode', 'critical-guidelines.md');
      files.push({ path: guidelinesFile, exists: fs.existsSync(guidelinesFile) });
      break;
    }
  }

  const installed = files.some((f) => f.exists);

  return { installed, files };
}

/**
 * Uninstall hooks for a project
 */
export function uninstallHooks(
  projectPath: string,
  ide: SupportedIDE
): { success: boolean; removed: string[]; errors: string[] } {
  const removed: string[] = [];
  const errors: string[] = [];

  const status = getHookStatus(projectPath, ide);

  for (const file of status.files) {
    if (file.exists) {
      try {
        fs.unlinkSync(file.path);
        removed.push(file.path);
        logger.info({ filePath: file.path }, 'Removed hook');
      } catch (error) {
        const errorMessage = `Failed to remove ${file.path}: ${error instanceof Error ? error.message : String(error)}`;
        errors.push(errorMessage);
        logger.error({ error, filePath: file.path }, 'Failed to remove hook');
      }
    }
  }

  return {
    success: errors.length === 0,
    removed,
    errors,
  };
}
