/**
 * Hook Generator Service
 *
 * Generates IDE-specific verification hooks and configuration files
 * for Claude Code and Cursor.
 */

import * as fs from 'fs';
import * as path from 'path';
import { getCriticalGuidelinesForScope } from './critical-guidelines.service.js';
import { createComponentLogger } from '../utils/logger.js';

const logger = createComponentLogger('hook-generator');

// =============================================================================
// TYPES
// =============================================================================

export type SupportedIDE = 'claude' | 'cursor' | 'vscode';

export interface HookConfig {
  ide: SupportedIDE;
  projectPath: string;
  projectId?: string;
  sessionId?: string;
}

export interface GeneratedHook {
  filePath: string;
  content: string;
  instructions: string;
}

export interface HookGenerationResult {
  success: boolean;
  hooks: GeneratedHook[];
  message: string;
}

// =============================================================================
// CLAUDE CODE HOOKS
// =============================================================================

/**
 * Generate the Claude Code verification hook script
 */
export function generateClaudeCodeHookScript(): string {
  return `#!/bin/bash
# Claude Code post-response verification hook
# Auto-generated by Agent Memory - verifies responses against critical guidelines
#
# Usage: This hook is called automatically after tool calls (Edit, Write, Bash)
# Environment: Requires agent-memory MCP server to be running

# Exit early if no stdin
if [ -t 0 ]; then
  exit 0
fi

# Read the tool output from stdin
TOOL_OUTPUT=$(cat)

# Skip verification for non-file operations
if [ -z "$TOOL_OUTPUT" ]; then
  exit 0
fi

# Check if this is a file modification tool
TOOL_NAME="\${CLAUDE_TOOL_NAME:-}"
case "$TOOL_NAME" in
  Edit|Write|Bash)
    # Continue with verification
    ;;
  *)
    # Skip verification for other tools
    exit 0
    ;;
esac

# Extract file path if available
FILE_PATH="\${CLAUDE_TOOL_ARG_FILE_PATH:-\${CLAUDE_TOOL_ARG_file_path:-}}"

# Build verification request
REQUEST="{
  \\"action\\": \\"post_check\\",
  \\"sessionId\\": \\"\${CLAUDE_SESSION_ID:-}\\",
  \\"completedAction\\": {
    \\"type\\": \\"file_write\\",
    \\"filePath\\": \\"$FILE_PATH\\",
    \\"content\\": $(echo "$TOOL_OUTPUT" | head -c 10000 | jq -Rs .),
    \\"description\\": \\"Tool: $TOOL_NAME\\"
  }
}"

# Call memory_verify via the MCP server
# Note: This requires the agent-memory MCP server to be running
RESULT=$(echo "$REQUEST" | npx -y agent-memory-client verify 2>/dev/null)

# Check for violations
if echo "$RESULT" | grep -q '"blocked"[[:space:]]*:[[:space:]]*true'; then
  echo "ERROR: Critical guideline violation detected!" >&2
  echo "$RESULT" | jq -r '.violations[]?.message // "Unknown violation"' 2>/dev/null >&2
  exit 1
fi

exit 0
`;
}

/**
 * Generate Claude Code settings.json hook configuration
 */
export function generateClaudeCodeSettings(projectPath: string): string {
  const hookScriptPath = path.join(projectPath, '.claude', 'hooks', 'verify-response.sh');

  return JSON.stringify(
    {
      hooks: {
        PostToolUse: [
          {
            matcher: 'Edit|Write|Bash',
            command: hookScriptPath,
          },
        ],
      },
    },
    null,
    2
  );
}

/**
 * Generate installation instructions for Claude Code hooks
 */
export function generateClaudeCodeInstructions(projectPath: string): string {
  return `
# Claude Code Verification Hook Installation

## Automatic Installation

Run the following command in your project directory:

\`\`\`bash
npx agent-memory-client setup-hook --ide=claude --project="${projectPath}"
\`\`\`

## Manual Installation

1. Create the hooks directory:
   \`\`\`bash
   mkdir -p "${path.join(projectPath, '.claude', 'hooks')}"
   \`\`\`

2. Copy the verification script to:
   \`${path.join(projectPath, '.claude', 'hooks', 'verify-response.sh')}\`

3. Make it executable:
   \`\`\`bash
   chmod +x "${path.join(projectPath, '.claude', 'hooks', 'verify-response.sh')}"
   \`\`\`

4. Add the hook configuration to your \`.claude/settings.json\`:
   \`\`\`json
   {
     "hooks": {
       "PostToolUse": [
         {
           "matcher": "Edit|Write|Bash",
           "command": "${path.join(projectPath, '.claude', 'hooks', 'verify-response.sh')}"
         }
       ]
     }
   }
   \`\`\`

## How It Works

- The hook runs after every Edit, Write, or Bash tool call
- It sends the tool output to the Agent Memory verification service
- If a critical guideline violation is detected, the hook returns exit code 1
- Claude Code will show the violation error to the user
`;
}

// =============================================================================
// CURSOR RULES
// =============================================================================

/**
 * Generate Cursor rules file with critical guidelines
 */
export function generateCursorRulesFile(
  projectId: string | null,
  sessionId?: string | null
): string {
  const guidelines = getCriticalGuidelinesForScope(projectId, sessionId);

  if (guidelines.length === 0) {
    return `# Critical Guidelines (Auto-synced from Agent Memory)

> No critical guidelines found. Guidelines with priority >= 90 will appear here.
> Last synced: ${new Date().toISOString()}
`;
  }

  let content = `# Critical Guidelines (Auto-synced from Agent Memory)

## MUST FOLLOW - Priority 90+

These guidelines are critical and must be followed in all interactions.
Call \`memory_verify pre_check\` before file modifications.

`;

  for (const guideline of guidelines) {
    content += `### ${guideline.name} (Priority: ${guideline.priority})\n\n`;
    content += `${guideline.content}\n\n`;

    if (guideline.rationale) {
      content += `**Rationale:** ${guideline.rationale}\n\n`;
    }

    if (guideline.examples) {
      if (guideline.examples.bad && guideline.examples.bad.length > 0) {
        content += `**Bad examples:**\n`;
        for (const bad of guideline.examples.bad) {
          content += `- \`${bad}\`\n`;
        }
        content += '\n';
      }

      if (guideline.examples.good && guideline.examples.good.length > 0) {
        content += `**Good examples:**\n`;
        for (const good of guideline.examples.good) {
          content += `- \`${good}\`\n`;
        }
        content += '\n';
      }
    }

    content += '---\n\n';
  }

  content += `> Last synced: ${new Date().toISOString()}\n`;
  content += `> Total critical guidelines: ${guidelines.length}\n`;

  return content;
}

/**
 * Generate installation instructions for Cursor rules
 */
export function generateCursorInstructions(projectPath: string): string {
  return `
# Cursor Rules Sync

## Automatic Sync

Run the following command to sync critical guidelines to Cursor:

\`\`\`bash
npx agent-memory-client sync-critical --ide=cursor --project="${projectPath}"
\`\`\`

## Manual Setup

1. The sync creates/updates this file:
   \`${path.join(projectPath, '.cursor', 'rules', 'critical-guidelines.md')}\`

2. Cursor will automatically include these rules in its context.

## Keeping Rules Updated

- Re-run the sync command whenever critical guidelines change
- Consider adding the sync to your project's pre-commit hooks
- Or set up a scheduled task to sync periodically
`;
}

// =============================================================================
// MAIN GENERATION FUNCTIONS
// =============================================================================

/**
 * Generate all hooks for a specific IDE
 */
export function generateHooks(config: HookConfig): HookGenerationResult {
  const hooks: GeneratedHook[] = [];

  try {
    switch (config.ide) {
      case 'claude': {
        // Generate hook script
        hooks.push({
          filePath: path.join(config.projectPath, '.claude', 'hooks', 'verify-response.sh'),
          content: generateClaudeCodeHookScript(),
          instructions: generateClaudeCodeInstructions(config.projectPath),
        });

        // Generate settings snippet
        hooks.push({
          filePath: path.join(config.projectPath, '.claude', 'settings-hook.json'),
          content: generateClaudeCodeSettings(config.projectPath),
          instructions: 'Merge this configuration into your .claude/settings.json',
        });

        break;
      }

      case 'cursor': {
        // Generate rules file
        hooks.push({
          filePath: path.join(config.projectPath, '.cursor', 'rules', 'critical-guidelines.md'),
          content: generateCursorRulesFile(config.projectId ?? null, config.sessionId),
          instructions: generateCursorInstructions(config.projectPath),
        });

        break;
      }

      case 'vscode': {
        // VSCode doesn't have native hooks, but we can provide rules
        hooks.push({
          filePath: path.join(config.projectPath, '.vscode', 'critical-guidelines.md'),
          content: generateCursorRulesFile(config.projectId ?? null, config.sessionId),
          instructions: 'VSCode does not support native hooks. This file contains critical guidelines for reference.',
        });

        break;
      }

      default:
        return {
          success: false,
          hooks: [],
          message: `Unsupported IDE: ${config.ide}`,
        };
    }

    logger.info({ ide: config.ide, hookCount: hooks.length }, 'Generated hooks');

    return {
      success: true,
      hooks,
      message: `Generated ${hooks.length} hook(s) for ${config.ide}`,
    };
  } catch (error) {
    logger.error({ error, config }, 'Failed to generate hooks');
    return {
      success: false,
      hooks: [],
      message: `Failed to generate hooks: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}

/**
 * Install generated hooks to the filesystem
 */
export function installHooks(hooks: GeneratedHook[]): { success: boolean; installed: string[]; errors: string[] } {
  const installed: string[] = [];
  const errors: string[] = [];

  for (const hook of hooks) {
    try {
      // Create directory if it doesn't exist
      const dir = path.dirname(hook.filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Write the file
      fs.writeFileSync(hook.filePath, hook.content, 'utf-8');

      // Make shell scripts executable
      if (hook.filePath.endsWith('.sh')) {
        fs.chmodSync(hook.filePath, '755');
      }

      installed.push(hook.filePath);
      logger.info({ filePath: hook.filePath }, 'Installed hook');
    } catch (error) {
      const errorMessage = `Failed to install ${hook.filePath}: ${error instanceof Error ? error.message : String(error)}`;
      errors.push(errorMessage);
      logger.error({ error, filePath: hook.filePath }, 'Failed to install hook');
    }
  }

  return {
    success: errors.length === 0,
    installed,
    errors,
  };
}

/**
 * Get hook status for a project
 */
export function getHookStatus(
  projectPath: string,
  ide: SupportedIDE
): { installed: boolean; files: { path: string; exists: boolean }[] } {
  const files: { path: string; exists: boolean }[] = [];

  switch (ide) {
    case 'claude': {
      const hookScript = path.join(projectPath, '.claude', 'hooks', 'verify-response.sh');
      const settings = path.join(projectPath, '.claude', 'settings.json');
      files.push(
        { path: hookScript, exists: fs.existsSync(hookScript) },
        { path: settings, exists: fs.existsSync(settings) }
      );
      break;
    }

    case 'cursor': {
      const rulesFile = path.join(projectPath, '.cursor', 'rules', 'critical-guidelines.md');
      files.push({ path: rulesFile, exists: fs.existsSync(rulesFile) });
      break;
    }

    case 'vscode': {
      const guidelinesFile = path.join(projectPath, '.vscode', 'critical-guidelines.md');
      files.push({ path: guidelinesFile, exists: fs.existsSync(guidelinesFile) });
      break;
    }
  }

  const installed = files.some((f) => f.exists);

  return { installed, files };
}

/**
 * Uninstall hooks for a project
 */
export function uninstallHooks(
  projectPath: string,
  ide: SupportedIDE
): { success: boolean; removed: string[]; errors: string[] } {
  const removed: string[] = [];
  const errors: string[] = [];

  const status = getHookStatus(projectPath, ide);

  for (const file of status.files) {
    if (file.exists) {
      try {
        fs.unlinkSync(file.path);
        removed.push(file.path);
        logger.info({ filePath: file.path }, 'Removed hook');
      } catch (error) {
        const errorMessage = `Failed to remove ${file.path}: ${error instanceof Error ? error.message : String(error)}`;
        errors.push(errorMessage);
        logger.error({ error, filePath: file.path }, 'Failed to remove hook');
      }
    }
  }

  return {
    success: errors.length === 0,
    removed,
    errors,
  };
}
