---
description: Design patterns and conventions used in the codebase
globs: ["**/*.ts"]
alwaysApply: false
---

# Design Patterns and Conventions

## Action-Based Routing Pattern

### Overview

MCP tools are bundled with action-based routing. Instead of 45+ individual tools, we have 17 tools with multiple actions each.

### Implementation

**Server layer** (`src/mcp/server.ts`):
```typescript
const bundledHandlers: Record<string, (params: Record<string, unknown>) => unknown> = {
  memory_knowledge: (params) => {
    const { action, ...rest } = params;
    switch (action) {
      case 'add':
        return knowledgeHandlers.add(rest);
      case 'update':
        return knowledgeHandlers.update(rest);
      // ... other actions
      default:
        throw new Error(`Unknown action for memory_knowledge: ${String(action)}`);
    }
  }
};
```

**Handler layer** (`src/mcp/handlers/knowledge.handler.ts`):
```typescript
export const knowledgeHandlers = {
  add(params: Record<string, unknown>) { ... },
  update(params: Record<string, unknown>) { ... },
  // ... other actions
};
```

### Benefits

- **Reduced tool count**: 17 tools instead of 45+
- **Consistent interface**: All tools follow same action pattern
- **Type safety**: Shared parameter types per tool
- **Easier maintenance**: Related actions grouped together

## Append-Only Versioning Pattern

### Overview

All memory entries use append-only versioning. Updates never modify existing versions; they create new versions.

### Implementation

**Repository pattern**:
```typescript
update(id: string, input: UpdateKnowledgeInput): KnowledgeWithVersion | undefined {
  return transaction(() => {
    // 1. Get existing entry and latest version
    const existing = this.getById(id);
    const latestVersion = db.select()
      .from(knowledgeVersions)
      .where(eq(knowledgeVersions.knowledgeId, id))
      .orderBy(desc(knowledgeVersions.versionNum))
      .get();
    
    // 2. Calculate new version number
    const newVersionNum = (latestVersion?.versionNum ?? 0) + 1;
    
    // 3. Check for conflicts (5-second window)
    let conflictFlag = false;
    if (latestVersion) {
      const lastWriteTime = new Date(latestVersion.createdAt).getTime();
      const currentTime = Date.now();
      if (currentTime - lastWriteTime < CONFLICT_WINDOW_MS) {
        conflictFlag = true;
        // Log conflict
      }
    }
    
    // 4. Create new version (never modify existing)
    const newVersion: NewKnowledgeVersion = {
      id: generateId(),
      knowledgeId: id,
      versionNum: newVersionNum,
      content: input.content ?? previousVersion?.content ?? '',
      // ... other fields
      conflictFlag,
    };
    db.insert(knowledgeVersions).values(newVersion).run();
    
    // 5. Update current version pointer
    db.update(knowledge).set({ currentVersionId: newVersionId }).where(eq(knowledge.id, id)).run();
    
    return this.getById(id);
  });
}
```

### Benefits

- **Full history**: Complete audit trail
- **Conflict detection**: Can detect concurrent writes
- **Rollback capability**: Can revert to any version
- **Immutable data**: Previous versions never change

## Scope Inheritance Pattern

### Overview

Queries can inherit from parent scopes. When querying a session, can also search project, org, and global scopes.

### Implementation

**Service layer** (`src/services/query.service.ts`):
```typescript
export function resolveScopeChain(input?: {
  type: ScopeType;
  id?: string;
  inherit?: boolean;
}): ScopeDescriptor[] {
  const inherit = input?.inherit ?? true;
  const chain: ScopeDescriptor[] = [];
  
  switch (input.type) {
    case 'session': {
      const sessionId = input.id ?? null;
      chain.push({ scopeType: 'session', scopeId: sessionId });
      
      if (inherit && sessionId) {
        // Get project from session
        const session = db.select().from(sessions).where(eq(sessions.id, sessionId)).get();
        if (session?.projectId) {
          chain.push({ scopeType: 'project', scopeId: session.projectId });
          
          // Get org from project
          const project = db.select().from(projects).where(eq(projects.id, session.projectId)).get();
          if (project?.orgId) {
            chain.push({ scopeType: 'org', scopeId: project.orgId });
          }
        }
      }
      
      if (inherit) {
        chain.push({ scopeType: 'global', scopeId: null });
      }
      break;
    }
    // ... other scope types
  }
  
  return chain;
}
```

### Usage

```typescript
// Query with inheritance (default)
const results = executeMemoryQuery({
  scope: { type: 'session', id: sessionId, inherit: true },
  types: ['guidelines']
});
// Searches: session → project → org → global

// Query without inheritance
const results = executeMemoryQuery({
  scope: { type: 'session', id: sessionId, inherit: false },
  types: ['guidelines']
});
// Searches: session only
```

### Benefits

- **Flexibility**: Can search specific scope or inherit
- **Efficiency**: Don't need multiple queries
- **Priority**: Results from child scopes override parent scopes

## Permission Check Pattern

### Overview

All write operations check permissions before executing. Read operations check permissions before returning results.

### Implementation

**Service layer** (`src/services/permission.service.ts`):
```typescript
export function checkPermission(
  agentId: string,
  action: 'read' | 'write' | 'delete',
  entryType: PermissionEntryType,
  entryId: string | null,
  scopeType: ScopeType,
  scopeId: string | null
): boolean {
  // Check permissions table for matching rules
  // Returns true if permission granted, false otherwise
}
```

**Handler usage**:
```typescript
add(params: Record<string, unknown>) {
  const { scopeType, scopeId, agentId } = cast<KnowledgeAddParams & { agentId?: string }>(params);
  
  // Check permission (write required for add)
  if (agentId && !checkPermission(agentId, 'write', 'knowledge', null, scopeType, scopeId ?? null)) {
    throw new Error('Permission denied: write access required');
  }
  
  // Proceed with creation
  const knowledge = knowledgeRepo.create(input);
  return { success: true, knowledge };
}
```

### Permission Granularity

- **Per-agent**: Each agent has separate permissions
- **Per-scope**: Can grant permissions for specific scopes
- **Per-entry-type**: Can grant permissions for tools, guidelines, or knowledge
- **Per-entry**: Can grant permissions for specific entries
- **Actions**: `read`, `write`, `admin`

## Audit Logging Pattern

### Overview

All actions are logged to the audit log for compliance and debugging.

### Implementation

**Service layer** (`src/services/audit.service.ts`):
```typescript
export function logAction(params: {
  agentId?: string;
  action: string;
  entryType?: PermissionEntryType;
  entryId?: string;
  scopeType?: ScopeType;
  scopeId?: string | null;
  queryParams?: Record<string, unknown>;
  resultCount?: number;
  executionTime?: number;
  success?: boolean;
  errorMessage?: string;
}): void {
  // Insert into audit_log table
}
```

**Handler usage**:
```typescript
add(params: Record<string, unknown>) {
  // ... create entry ...
  
  // Log audit
  logAction({
    agentId,
    action: 'create',
    entryType: 'knowledge',
    entryId: knowledge.id,
    scopeType,
    scopeId: scopeId ?? null,
  });
  
  return { success: true, knowledge };
}
```

### Benefits

- **Compliance**: Full audit trail
- **Debugging**: Track all operations
- **Analytics**: Usage patterns and performance

## Duplicate Detection Pattern

### Overview

When creating entries, check for potential duplicates and warn (but don't block).

### Implementation

**Service layer** (`src/services/duplicate.service.ts`):
```typescript
export function checkForDuplicates(
  entryType: PermissionEntryType,
  name: string,
  scopeType: ScopeType,
  scopeId: string | null
): {
  isDuplicate: boolean;
  similarEntries: Array<{ name: string; similarity: number }>;
} {
  // Use Levenshtein distance to find similar entries
  // Return similarity scores
}
```

**Handler usage**:
```typescript
add(params: Record<string, unknown>) {
  // ... validation ...
  
  // Check for duplicates (warn but don't block)
  const duplicateCheck = checkForDuplicates('knowledge', title, scopeType, scopeId ?? null);
  if (duplicateCheck.isDuplicate) {
    console.warn(
      `[duplicate] Potential duplicate knowledge entry found: "${title}". Similar entries:`,
      duplicateCheck.similarEntries.map((e) => `${e.name} (${(e.similarity * 100).toFixed(1)}% similar)`)
    );
  }
  
  // Proceed with creation
}
```

## Red Flag Detection Pattern

### Overview

Detect unreliable patterns in entries (e.g., vague content, missing sources).

### Implementation

**Service layer** (`src/services/redflag.service.ts`):
```typescript
export function detectRedFlags(params: {
  type: PermissionEntryType;
  content: string;
}): Array<{ pattern: string; severity: 'low' | 'medium' | 'high'; description: string }> {
  // Check for red flag patterns
  // Return array of detected issues
}
```

**Handler usage**:
```typescript
add(params: Record<string, unknown>) {
  // ... create entry ...
  
  // Check for red flags
  const redFlags = detectRedFlags({
    type: 'knowledge',
    content: content || '',
  });
  if (redFlags.length > 0) {
    console.warn(
      `[redflag] Red flags detected in knowledge entry "${title}":`,
      redFlags.map((f) => `${f.pattern} (${f.severity}): ${f.description}`)
    );
  }
  
  return { success: true, knowledge, redFlags: redFlags.length > 0 ? redFlags : undefined };
}
```

## Query Caching Pattern

### Overview

Cache global scope queries (which rarely change) to improve performance.

### Implementation

**Service layer** (`src/services/query.service.ts`):
```typescript
class QueryCache {
  private cache = new Map<string, CacheEntry<unknown>>();
  private ttl = 5 * 60 * 1000; // 5 minutes
  
  get<T>(params: MemoryQueryParams): T | null {
    const key = this.getCacheKey(params);
    if (!key) return null;
    
    const entry = this.cache.get(key) as CacheEntry<T> | undefined;
    if (!entry) return null;
    
    const age = Date.now() - entry.timestamp;
    if (age > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value;
  }
  
  set<T>(params: MemoryQueryParams, value: T): void {
    const key = this.getCacheKey(params);
    if (!key) return;
    
    this.cache.set(key, { value, timestamp: Date.now() });
  }
}
```

**Usage**:
```typescript
export function executeMemoryQuery(params: MemoryQueryParams): MemoryQueryResult {
  // Check cache first
  const cached = queryCache.get<MemoryQueryResult>(params);
  if (cached) {
    return cached;
  }
  
  // Execute query
  const result = { ... };
  
  // Cache result
  queryCache.set(params, result);
  
  return result;
}
```

### Cache Strategy

- **Conservative**: 5-minute TTL, 100 entry max
- **Aggressive**: 10-minute TTL, 200 entry max
- **Disabled**: No caching

## Embedding Generation Pattern

### Overview

Generate embeddings asynchronously (fire-and-forget) for semantic search.

### Implementation

**Repository hooks** (`src/db/repositories/embedding-hooks.ts`):
```typescript
export function generateEmbeddingAsync(params: {
  entryType: PermissionEntryType;
  entryId: string;
  versionId: string;
  text: string;
}): void {
  // Fire-and-forget async operation
  // Don't await, don't block
  Promise.resolve().then(async () => {
    try {
      const embeddingService = getEmbeddingService();
      if (embeddingService.isAvailable()) {
        const result = await embeddingService.embed(params.text);
        // Store embedding in vector database
        const vectorService = getVectorService();
        await vectorService.storeEmbedding({
          entryType: params.entryType,
          entryId: params.entryId,
          versionId: params.versionId,
          embedding: result.embedding,
        });
      }
    } catch (error) {
      // Log error but don't fail the operation
      console.error('[embedding] Failed to generate embedding:', error);
    }
  });
}
```

**Repository usage**:
```typescript
create(input: CreateKnowledgeInput): KnowledgeWithVersion {
  return transaction(() => {
    // ... create entry and version ...
    
    // Generate embedding asynchronously (fire-and-forget)
    const text = extractTextForEmbedding('knowledge', input.title, {
      content: input.content,
      source: input.source,
    });
    generateEmbeddingAsync({
      entryType: 'knowledge',
      entryId: knowledgeId,
      versionId: versionId,
      text,
    });
    
    return result;
  });
}
```

### Benefits

- **Non-blocking**: Doesn't slow down create/update operations
- **Resilient**: Failures don't affect main operation
- **Background processing**: Embeddings generated in background

## Type Casting Pattern

### Overview

Safely cast MCP parameters to typed interfaces.

### Implementation

**Handler pattern**:
```typescript
// Helper function
function cast<T>(params: Record<string, unknown>): T {
  return params as unknown as T;
}

// Usage
add(params: Record<string, unknown>) {
  const {
    scopeType,
    scopeId,
    title,
    content,
    agentId,
  } = cast<KnowledgeAddParams & { agentId?: string }>(params);
  
  // Now have typed parameters
}
```

### Benefits

- **Type safety**: Get TypeScript autocomplete and type checking
- **Runtime safety**: Still need to validate required fields
- **Consistency**: Same pattern across all handlers








